# 乐观锁抢票和悲观锁抢票实验报告

## 一、实验目的：

测试使用乐观锁和悲观锁两者在多线程并发抢票时的影响来探究两者区别

## 二、实验环境：

操作系统：windows

cpu：inter i5-10400f 六核十二线程

使用工具：idea，vscode，navicate，postman

## 三、实验步骤：

1.在项目原有基础上后端controller层新建两个方法，一个为testCAS(),一个为testSync（）模拟多线程并发进行抢票，并设计统计时间的方法（具体设计见附一）；

2.后端service层，dao层新建使用悲观锁抢票的方法逻辑（抢票方法设为synchronized，去除查询版本号和比对版本号的逻辑）。

3.运行后端项目

4.使用nivacte将前200张票信息设置为status=1，userId=null,buy_time=null,version=0

5.使用postman分别提交controller层所映射的路径，并提交创建线程数count参数

6.在idea中记录相应实验数据

7.更新数据库状态

8.重复4-7步骤，统计数据

9.分析数据，得出结论

## 四、实验结果：

#### 乐观锁

| 实验次数 | 线程数 | 票数 | 所用时间/MS | 未抢到票数 | 未抢到票人数 |
| -------- | ------ | ---- | ----------- | ---------- | ------------ |
| 1        | 1000   | 200  | 429         | 2/200      | 2/1000       |
| 2        | 100    | 200  | 618         | 120/200    | 20/100       |
| 3        | 1000   | 20   | 155         | 0          | 980          |
| 4        | 10000  | 200  | 8353        | 0          | 9800         |
| 5        | 10000  | 20   | 5775        | 0          | 9980         |
| 6        | 10000  | 200  | 6467        | 0          | 9800         |
| 7        | 10000  | 2    | 7370        | 0          | 9998         |
| 8        | 400    | 400  | 636         | 149/400    | 149/400      |

#### 悲观锁

| 实验次数 | 线程数 | 票数 | 所用时间 | 未抢到票数 | 未抢到票人数 |
| -------- | ------ | ---- | -------- | ---------- | ------------ |
| 1        | 1000   | 200  | 1507     | 0          | 0            |
| 2        | 100    | 200  | 442      | 23/200     | 23/100       |
| 3        | 1000   | 20   | 1553     | 0          | 0            |
| 4        | 10000  | 200  | 6074     | 0          | 9800         |
| 5        | 10000  | 20   | 7482     | 0          | 9980         |
| 6        | 10000  | 200  | 6092     | 0          | 9800         |
| 7        | 10000  | 2    | 60678    | 0          | 9998         |
| 8        | 400    | 400  | 255      | 143/400    | 143/900      |

## 五、结果分析

由上分析可知:

当并发冲突量（线程数/票数）越大时，使用乐观锁的效率大大高于悲观锁，但是当并发冲突量较小甚至小于0时，悲观锁效率与乐观锁高

由于本次买票采取的是随机数买票，且没有重试机制，所有发生买票冲突（未买到票）的人数比基本类似，没有过多参考价值，

而本次电影院买票系统，部分热门电影可能会存在高并发的抢票需求，所以选择乐观锁比较合适

### 附一：

乐观锁多线程抢票测试接口代码

~~~java
@GetMapping("/test/cas")
void testCAS(int count){

    CountDownLatch start = new CountDownLatch(1);
    CountDownLatch end = new CountDownLatch(count);
    Random random=new Random();
    StopWatch stopWatch = new StopWatch("乐观锁买票耗时统计");
    for (int i = 0; i < count; i++) {
        Thread t =new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //阻塞线程，当所有线程全部创建并就绪再唤醒
                    start.await();
                    customerService.updateTicket(random.nextInt(400)+1,8);
                    System.out.println(Thread.currentThread().getName());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    end.countDown();
                }
            }
        });
        t.start();

    }

    stopWatch.start("更新状态");
    //唤醒所有线程同一时间开始工作
    start.countDown();

    try {
        //主线程阻塞,等待其他所有 worker 线程完成后再执行
        end.await();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    stopWatch.stop();
    System.out.println(stopWatch.prettyPrint());
    System.out.println(stopWatch.getTotalTimeMillis());
    System.out.println("主程序结束");
}
~~~

悲观锁多线程抢票测试接口代码

~~~java
@GetMapping("/test/sync")
void  testSync(int count){
    CountDownLatch start = new CountDownLatch(1);
    CountDownLatch end = new CountDownLatch(count);
    Random random=new Random();
    StopWatch stopWatch = new StopWatch("悲观锁买票耗时统计");
    for (int i = 0; i < count; i++) {
        Thread t =new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //阻塞线程，当所有线程全部创建并就绪再唤醒
                    start.await();
                    synchronized(this) {
                        customerService.updateTicketBySync(random.nextInt(400) + 1, 8);
                    }
                    System.out.println(Thread.currentThread().getName());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    end.countDown();
                }
            }
        });
        t.start();

    }
    stopWatch.start("更新状态");
    //唤醒所有线程同一时间开始工作
    start.countDown();

    try {
        //主线程阻塞,等待其他所有 worker 线程完成后再执行
        end.await();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    stopWatch.stop();
    System.out.println(stopWatch.prettyPrint());
    System.out.println(stopWatch.getTotalTimeMillis());
    System.out.println("主程序结束");
}
~~~





